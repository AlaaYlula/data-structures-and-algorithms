/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package breadth_first;

import java.util.ArrayList;
import breadth_first.Queue.Queue;
import java.util.List;
public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        System.out.println(new App().getGreeting());

        BinaryTree binaryTree = new BinaryTree();

        binaryTree.setRoot(new Node(2));
        //level 1
        binaryTree.getRoot().setLeftNode(new Node(7));
        binaryTree.getRoot().setRightNode(new Node(5));
        //level 2
        binaryTree.getRoot().getLeftNode().setLeftNode(new Node(2));
        binaryTree.getRoot().getLeftNode().setRightNode(new Node(6));
        binaryTree.getRoot().getRightNode().setRightNode(new Node(9));
        //level 3
        binaryTree.getRoot().getLeftNode().getRightNode().setLeftNode(new Node(5));
        binaryTree.getRoot().getLeftNode().getRightNode().setRightNode(new Node(11));
        binaryTree.getRoot().getRightNode().getRightNode().setLeftNode(new Node(4));


        BinarySearchTree binarySearchTree = new BinarySearchTree();
        binarySearchTree.add(10);
        binarySearchTree.add(5);
        binarySearchTree.add(2);
        binarySearchTree.add(20);


        System.out.println("//////////////// Recursion Binary Tree");
        List<Integer> resultRecursion = breadthFirstRecursion(binaryTree);
        System.out.println("Result => " + resultRecursion);

        System.out.println("//////////////// Recursion Binary Search Tree");
        List<Integer> resultSearchRecursion = breadthFirstRecursion(binarySearchTree);
        System.out.println("Result => " + resultSearchRecursion);

        System.out.println("////////////// Build in the Binary tree and binary search tree class ////////////////");
        System.out.println("Binary Tree => "+binaryTree.breadthFirst());
        System.out.println("Binary Search Tree => "+binarySearchTree.breadthFirst());

        System.out.println("//////////////// Binary Tree Method breadthFirst");

        List<Integer> reult = breadthFirst(binaryTree);
        System.out.println("Result => " + reult);

        System.out.println("///////////////////// Binary Search Tree Method breadthFirst");

        List<Integer> result = breadthFirst(binarySearchTree);
        System.out.println("Result => " + result);


    }

    ////////////////////////////// Method /////////////////////////////
    public static List<Integer> breadthFirst(Tree tree) {
        List<Integer> resultList = new ArrayList<>();
        if (tree.getClass().getSimpleName().equals("BinaryTree")) {
            BinaryTree binaryTree = (BinaryTree) tree;
            if (binaryTree.getRoot() != null) {
                Queue<Node> queue = new Queue<>();
                queue.enqueue(binaryTree.getRoot());

                Node node;
                while (queue.getFront() != null) {
                    node = queue.dequeue();
                    //System.out.print(node.getData() + " => ");
                    resultList.add(node.getData());
                    if (node.getLeftNode() != null) {
                        queue.enqueue(node.getLeftNode());
                    }

                    if (node.getRightNode() != null) {
                        queue.enqueue(node.getRightNode());
                    }
                }
            } else {
                System.out.println("Tree empty");
            }
        }else if(tree.getClass().getSimpleName().equals("BinarySearchTree")){
            BinarySearchTree binarySearchTree = (BinarySearchTree) tree;
            if (binarySearchTree.getRoot() != null) {
                Queue<Node> queue = new Queue<>();
                queue.enqueue(binarySearchTree.getRoot());

                Node node;
                while (queue.getFront() != null) {
                    node = queue.dequeue();
                   // System.out.print(node.getData() + " => ");
                    resultList.add(node.getData());
                    if (node.getLeftNode() != null) {
                        queue.enqueue(node.getLeftNode());
                    }

                    if (node.getRightNode() != null) {
                        queue.enqueue(node.getRightNode());
                    }
                }
            } else {
                System.out.println("Tree empty");
            }
        }
        return resultList;
    }
//////////////////////////////// Recursion //////////////////////////
    public static List<Integer> breadthFirstRecursion(Tree tree) {
        List<Integer> resultList = new ArrayList<>();
        Queue<Node> queue = new Queue<>();
        if (tree.getClass().getSimpleName().equals("BinaryTree")) {
            BinaryTree binaryTree = (BinaryTree) tree;
            if(binaryTree.getRoot() != null){ // if the root not null add it to the Queue
                queue.enqueue(binaryTree.getRoot());
                return breadthFirstRecursion(queue,resultList);
            }
        } else if(tree.getClass().getSimpleName().equals("BinarySearchTree")){
            BinarySearchTree binarySearchTree = (BinarySearchTree) tree;
            if(binarySearchTree.getRoot() != null){ // if the root not null add it to the Queue
                queue.enqueue(binarySearchTree.getRoot());
                return breadthFirstRecursion(queue,resultList);
            }
        }
        return null; // If Empty
    }
    public static List<Integer> breadthFirstRecursion(Queue<Node> queue,List<Integer> resultList) {
            if (!queue.isEmpty()) { // if the queue is not empty dequeue and add it to the list and check the left and right
                Node node = queue.dequeue();
                resultList.add(node.getData());

                if (node.getLeftNode() != null) { // if the root has left node then enqueue the left
                    queue.enqueue(node.getLeftNode());
                }
                if (node.getRightNode() != null) {// if the root has right node then enqueue the right
                    queue.enqueue(node.getRightNode());
                }
                return breadthFirstRecursion(queue, resultList);
            }
            return resultList;
    }
}